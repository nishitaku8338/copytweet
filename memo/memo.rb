フォームからのデータの保存方法について
createアクションはフォームで送られてきたデータを元に、レコードを保存する
ストロングパラメーターを使用した保存方法


ストロングパラメーター
ストロングパラメーターとは、
指定したキーを持つパラメーターのみを受け取るように制限するもの。
ストロングパラメーターを使用する理由は、
受け取るパラメーターを制限しなければ、
仕様以外のパラメーターも使われてしまうためである。
この状態だと、意図しないデータの更新をされる可能性が発生する。
(他人のログインパスワードを変更するパラメーターを追加で送信すれば、勝手にパスワードを変更できてしまう)
これを回避するために、ストロングパラメーターを使用し、パラメーターを制限する必要がある
ストロングパラメーターの定義には、requireメソッドと、permitメソッドを組み合わせて使用する。


requireメソッド
送信されたパラメーターの情報を持つparamsが、使用できるメソッド。
requireメソッドは、パラメーターからどの情報を取得するか、選択する。
ストロングパラメーターとして使用する場合は、主にモデル名を指定する。
【例】require
params.require(:モデル名)  # 取得したい情報を指定する

params[:モデル名]としても同じ情報を取得できるが、
requireメソッドを使うことで、
意図しないパラメーターであった場合にエラーとして返すことができ、
原因特定やユーザーにエラーを示すなどの対応ができる。
以上のように、
requireメソッドによって必要なパラメーターのほとんどを取得できるが、
取得するパラメーターをより意図したものだけに制限するため、
permitメソッドを使用して、
カラムに保存したいデータのみに絞る。


permitメソッド
requireメソッドと同様に、paramsが使用できるメソッド。
permitメソッドを使用すると、
取得したいキーを指定でき、指定したキーと値のセットのみを取得する。
【例】permit
params.require(:モデル名).permit(:キー名, :キー名) # 取得したいキーを指定する

permitメソッドでparams.requireの内容からキーを指定すると、
それ以外のキーがあっても値を受け付けない。


プライベートメソッド
クラス外から呼び出すことのできないメソッドのこと。

プライベートメソッドのメリットは以下の2点
1. Classの外部から呼ばれたら困るメソッドを隔離
メソッドの中には、
Classの外部から呼び出されてしまうとエラーを起こすメソッドも存在する。
プライベートメソッドはClass外から呼び出すことが不可能であるため、
誤って呼び出してしまう等によるエラーを事前に防ぐことができる。

2. 可読性
Classの外部から呼び出されるメソッドを探すときに、
private以下の部分は目を通さなくて良くなる。
また、繰り返し使用するメソッドもprivate以下に集約できるので、
コードをシンプルにできる。



データの入力に制約をかける
バリデーション
データを登録する際に、一定の制約をかけること。
・空のデータが登録できないようにする
・すでに登録されている文字列を登録できないようにする（メールアドレスの登録など）
・文字数制限をかける（パスワードなど）
バリデーションを設ける際は、モデルにvalidatesメソッドを記述する。

validates
validatesとは、バリデーションを設定する時に使用するメソッド。
【例】モデルファイル
validates :カラム名, バリデーションの種類

presence: trueと記述することで、
nameカラムが「空ではないか」というバリデーションを設ける
【例】モデルファイル
validates :name, presence: true

このバリデーションを設けることで、
名前が空欄の時データベースに保存できなくなる。
つまり、値を必ず入力しなければ、登録する時エラーが発生する。


HTTPメソッドのおさらい
・GETメソッド
サーバーからブラウザに情報を返す。
単にウェブサイトを閲覧する際など、情報を取得するために利用される。

・POSTメソッド
ブラウザからサーバーに情報を送信し、サーバーに情報を保存する。
情報を登録する際など、サーバーに情報を送信するために利用される。

・DELETEメソッド
ブラウザからサーバーに情報を送信し、サーバーの情報を削除する。
アカウントを削除する際など、サーバー内のデータを削除するために利用される。

・PATCHメソッド
ブラウザからサーバーに情報を送信し、サーバー内の情報を置き換える。
登録情報を更新する際など、サーバー内のデータを更新するために利用される。

Railsではこれら4つのメソッドを利用して開発を行なっており、その役割や機能が分かれている。



メソッドによるコード省略
同じコードをメソッドにまとめる
・before_action
before_actionを使用すると、
コントローラで定義されたアクションが実行される前に、共通の処理を行うことができるメソッド。
【例】before_action
class コントローラ名 < ApplicationController
  before_action :処理させたいメソッド名, オプション名
end

・onlyオプション
resourcesと同様にonlyやexceptなどのオプションを使用することによって、
どのアクションの実行前に、処理を実行させるかなど制限が可能になる。



ライブラリをインストール
ログイン機能を実装するために、deviseというGemを使用
・devise
ユーザー管理機能を簡単に実装するためのGem。
実際に運用されている多くのRailsアプリケーションサービスで使用されている。

追記する場所は、Gemfileの最後の行
Gemfile
# 中略
gem 'devise'

コマンドを実行してGemをインストール
ターミナル
# 現在のディレクトリが~/projects/pictweetであることを確認
% pwd

# Gemをインストール
% bundle install

ローカルサーバーを再起動
Gemをインストールした後はrails sをcontrol + Cで一度停止し、
サーバーを再起動する必要がある。
これは、インストールしたGemの反映するタイミングが、サーバー起動時だからである。
ターミナル
# サーバーを起動
% rails s


deviseの設定ファイルを作成
deviseを使用するためには、Gemのインストールに加え、
devise専用のコマンドで設定ファイルを作成する必要がある。

rails g devise:installコマンド
このコマンドは、
追加したdeviseというGemの「設定関連に使用するファイル」を自動で生成するコマンド。

コマンドを実行して設定ファイルを作成
ターミナル
# deviseの設定ファイルを作成
% rails g devise:install



deviseのUserモデルを作成
deviseを利用する際には、
アカウントを作成するためのUserモデルを新しく作成する必要がある。
作成には通常のモデルの作成方法ではなく、
deviseのモデル作成用コマンドでUserモデルを作成する。

rails g deviseコマンド
rails g deviseコマンドは、
deviseによるユーザー機能の対象を指定することで、
モデルとマイグレーションの生成やルーティングの設定などをまとめて処理できる。
実行すると、モデルが生成され、routes.rbにはdeviseに関連するパスが追加される。

コマンドを実行してUserモデルを作成
rails g deviseコマンドでuserを指定
ターミナル
# deviseコマンドでUserモデルを作成
% rails g devise user

ユーザーに関する、モデルやマイグレーションも自動生成される。
また、routes.rbに以下のルーティングが自動的に追記される。
【例】config/routes.rb
Rails.application.routes.draw do
  devise_for :users
end

devise_forは、
ユーザー機能に必要な複数のルーティングを一度に生成してくれるdeviseのメソッド。
※モデルとマイグレーションは作成されるが、usersテーブルは作成されていない。
そのため、このコマンドを実行した後にhttp://localhost:3000へアクセスするとエラーが生じる。
rails db:migrateを実行する必要があるが、
カラムのなど追加する必要がある場合、編集してからマイグレートを実行する。



deviseのビューファイルを作成
deviseでログイン機能を実装すると、
ログイン/サインアップ画面が自動的に生成されるが、
ビューファイルとしては生成されない。
これは、deviseのGem内に存在するビューファイルを読み込んでいるためである。
deviseのビューファイルに変更を加えるためには、
deviseのコマンドを利用して、ビューファイルを生成する必要がある。

rails g devise:viewsコマンド
deviseに用意されたビューファイルをコピーし、app/viewsの配下に配置してくれるコマンド。
HTMLを修正できるため、カスタマイズ可能になる。

コマンドを実行してdevise用のビューを作成
ターミナル
% rails g devise:views



ログイン・サインアップ画面のビューを編集
・サインアップ画面のビュー
app/views/devise/registrations/new.html.erb
・ログイン画面のビュー
app/views/devise/sessions/new.html.erb



usersテーブルにカラムを追加
現在、サインアップ時に登録する情報はメールアドレスとパスワードの2つ。
これに加えてニックネームを登録できるようにする。
テーブルにカラムを追加するために、マイグレーションを生成する必要がある。

rails g migrationコマンド
マイグレーションを生成するコマンド
このコマンドは、指定するファイルの名前によって、
どのようなテーブル操作を行うかを自動で記述する。
rails g migration Addカラム名To追加先テーブル名 追加するカラム名:型
とすることで、テーブルにカラムを追加する際に必要なコードが記述された状態で、マイグレーションが生成される。

スネークケースとキャメルケース
スネークケースとキャメルケースは、それぞれ単語の区切り方を表したもの
・スネークケースは、単語の区切りをアンダースコアで表す
admin_user_comment_creator
・キャメルケースは、単語の区切りを大文字で表す
adminUserCommentCreator
・アッパーキャメルケースは、キャメルケースの1つ。先頭から単語の区切りを大文字で表す
AdminUserCommentCreator


Railsの慣習的な命名規則
クラス名：アッパーキャメルケース
メソッド名：スネークケース
変数名：スネークケース


usersテーブルにnicknameカラムをstring型で追加
ユーザー名を保存するために新しいカラムを1つ追加する。
今回はこのカラム名をnicknameとする。マイグレーションファイルの作成と実行をする。
ターミナル
# ディレクトリがpictweetであることを確認
% pwd

# usersテーブルにnicknameカラムをstring型で追加するマイグレーションファイルを作成
% rails g migration AddNicknameToUsers nickname:string

# 作成したマイグレーションを実行
% rails db:migrate

※Addカラム名To追加先テーブルのカラム名の部分は、
必ずしも厳密なカラム名を入力する必要はない。
ただし、ファイル名を見ただけで動作を理解できる名前にしておくのが適切。
今回はnicknameというカラムを追加するのでNicknameと記述。



サインアップ画面を編集
ニックネーム情報をフォームから登録できるようにビューを編集する。
今回は、ニックネームを6文字以内で登録させるようにする。
このような文字数上限を設定する際に必要な、maxlengthオプションを使う。

maxlengthオプション
maxlengthオプションは、inputタグを生成するヘルパーメソッドである。
text_fieldにつけることができるオプションである。
入力できる最大文字数を指定できる。
【例】maxlengthオプション
<div class="field">
  <%= f.text_field :nickname, autofocus: true, maxlength: "6" %>
</div>

上記の場合、生成されたフォームに7文字以上入力すると、
エンターキーを押した瞬間に6文字になるまでカットされる。



ストロングパラメーターを使えるように
deviseに関しても、同様にストロングパラメーターをコントローラーに記述する。
しかし、deviseの処理を行うコントローラーはGem内に記述されているため、編集することができない。
また、deviseでログイン機能を実装した場合は、
paramsの他に、paramsとは異なる形のパラメーターも受け取っている。
以上から、deviseのコントローラーにストロングパラメーターを反映する方法と、
devise特有のパラメーターを取得する方法が、必要になる。
まずはdevise特有のパラメーターを取得するために、
deviseが提供しているdevise_parameter_sanitizerというメソッドを使う。

devise_parameter_sanitizerメソッド
deviseにおけるparamsのようなメソッド。
deviseのUserモデルに関わる「ログイン」「新規登録」などのリクエストからパラメーターを取得できる。
このメソッドとpermitメソッドを組み合わせることにより、
deviseに定義されているストロングパラメーターに対し、
自分で新しく追加したカラムも指定して含めることができる。

devise_parameter_sanitizerメソッドは、
これまでのストロングパラメーターと同じく、
新たに定義するプライベートメソッドの中で使用する。
deviseの提供元では、新たに定義するメソッド名を
configure_permitted_parameters
と紹介していることから、慣習的にこのメソッド名で定義することが多い。
【例】devise_parameter_sanitizerメソッド
private
def configure_permitted_parameters  # メソッド名は慣習
  # deviseのUserモデルにパラメーターを許可
  devise_parameter_sanitizer.permit(:deviseの処理名, keys: [:許可するキー])
end

ただし、あくまで慣習なので定義するメソッド名は自由につけても構話ない。

また、devise_parameter_sanitizerに使用するpermitメソッドの引数が、
これまでと異なる点に注目。
これは、deviseに定義されているpermitメソッドであり、
Railsではじめから使用できたpermitメソッドとは異なるものであるため。
【例】名前は同じでも、中身は異なるpermit
# paramsのpermitメソッド
params.require(:モデル名).permit(:許可するキー)

# devise_parameter_sanitizerのpermitメソッド
devise_parameter_sanitizer.permit(:deviseの処理名, keys: [:許可するキー])


deviseのpermitは、
第一引数にdeviseの処理名、
第二引数にkeysというキーに対し、
配列でキーを指定することで、許可するパラメーターを追加します。

第一引数の処理名には、deviseですでに設定されているsign_in,
sign_up, account_updateが使用でき、
それぞれサインイン時やサインアップ時、アカウント情報更新時の処理に対応する。

処理名            役割
:sign_in         サインイン（ログイン）の処理を行うとき
:sign_up         サインアップ（新規登録）の処理を行うとき
:account_update  アカウント情報更新の処理を行うとき

第一引数で指定した処理に対して、
第二引数のkeysで指定された名前と同じキーを持つパラメーターの取得を許可する。
ビューに記述した各フォーム部品のname属性値が、フォームから送信されるパラメーターのキーとなる。

deviseにストロングパラメーターを追加するコードは、
deviseのコントローラーが編集できないため、application_controller.rbに記述する。


application_controller.rbファイル
すべてのコントローラーが継承しているファイル。
すなわち、ここに処理を記述しておくことで、すべてのコントローラーで共通となる処理を作ることができる。
これまで作成したtweets_controller.rbやdeviseのコントローラーも、
application_controller.rbの処理が読み込まれた上で作られる仕組みになっている。

※deviseの処理に関わるコントローラーはGemに記述されており、編集ができない。
そのため、編集ができるapplication_controller.rbにストロングパラメーターを定義しておき、その処理を読み込ませる。


ブラウザで登録画面を確認
http://localhost:3000/users/sign_up



UI/UXを整える
ログインの有無で表示を変える
ヘッダー部分のHTMLは、すべてのビューで共通のテンプレートである
application.html.erbで編集できる。
application.html.erbを編集して、
未ログイン時とログイン時でボタンの表示を変える実装をする。
ログイン状態の確認には、user_signed_in?メソッドを使用する。

user_signed_in?メソッド
Gemのdeviseを導入しているため、使用できるメソッド。
ログインしているかどうかの判定を行う。
user_signed_in?メソッドは、
ユーザーがログインしていればtrueを、
ログアウト状態であればfalseを返す。
【例】user_signed_in?
# ログインしているユーザーのとき
user_signed_in?
#=> true

# ログインしていないユーザーのとき
user_signed_in?
#=> false


link_toで作成したリンクは、デフォルトでGETメソッドを使用している。
そのため、DELETEメソッドを使用する際はmethodオプションに:deleteの指定が必要。
GETメソッドを使用する場合は、methodオプションを省略できる。
また、ログアウト以外にはclassオプションを使い、class属性をつけることで、CSSが適用されるようにする。



未ログイン状態のユーザーを転送
ログインしてない状態でも、「投稿する」ボタンの遷移先であるURLを直接入力すると、
新規投稿ページにアクセスできてしまう。
そこで、未ログインユーザーが投稿画面など直接アクセスしてきた際には、
ルートパスに遷移するように設定を行う。
このような仕組みをリダイレクトと言う。
tweets_controller.rbのすべてのアクションに対して、
「もし、ユーザーがログインしていなかったらindexアクションにリダイレクトする」ような機能を実装。

リダイレクト
「本来受け取ったパスとは別のパスへ転送する」機能のこと。
リダイレクトを利用すると、アクションに処理を持たせて実行した上で、
そのパスのビューを返すのではなく別の意図したパスにユーザーを転送させることができる。
今回は未ログインユーザを別のパスへ転送するため、
未ログインユーザを判別する必要がある。
この判別には、user_signed_in?とunlessを用いる。

unless
ifと同様に、条件式の返り値で条件分岐して処理を実行するRubyの構文。
ifは返り値がtrueのときにelseまでの処理が実行されるが、
unlessはfalseのときにelseまでの処理が実行される。
【例】unless
unless 条件式
  # 条件式がfalseのときに実行する処理
end 

このunlessを用いて「ログインしているユーザーでない」ときの処理に、
リダイレクトを設定する。
Railsではリダイレクト処理に、redirect_toメソッドを使用する。

redirect_toメソッド
Railsでリダイレクト処理を行う際に使用するメソッド。
コントローラー等での処理が終わった後、
アクションに対応するビューファイルを参照せずに、
別ページへリダイレクトさせることができる。
【例】redirect_to
redirect_to action: :リダイレクト先となるアクション名

今回はリダイレクト処理を定義して、before_acitionで実行させますが、
一部のアクションについては処理を実行させたくないため、
exceptオプションを使用し指定する必要がある。

exceptオプション
before_actionで使用できるオプション。
exceptは「除外する」という意味。
exceptと指定したアクションに対しては、事前処理は実行されない。

要点チェック
deviseとは、ユーザー管理機能を簡単に実装するためのGemのこと
rails g devise:install コマンドとは、deviseというGemの設定関連に使用するファイルを自動で生成するコマンドのこと
rails g deviseコマンドとは、deviseの中で使用するユーザーモデルclass名を置き換え、modelなど必要なファイルを生成するコマンドのこと
rails g devise:viewsコマンドとは、deviseで自動生成されたログインや新規作成画面を変更する際に使用するコマンドのこと
user_signed_in?メソッドとは、ログインしているユーザー情報を取得するメソッドのこと
リダイレクトとは、「本来受け取ったパスとは別のパスへ転送する」こと
redirect_toメソッドとは、指定先にリダイレクトさせるメソッドのこと
rails g migrationコマンドとは、マイグレーションファイルを生成するためのコマンド。命名規則に沿うと、必要なマイグレーションが記述された状態で生成されること
スネークケースとキャメルケースとは、複数の単語が連立する場合に使用する命名パターンのこと
devise_parameter_sanitizerメソッドとは、deviseでユーザー登録する場合に使用できる、「特定のカラムを許容する」メソッドのこと
application_controller.rbファイルとは、rails g controllerが生成するコントローラーが予め継承しているコントローラーのこと



ツイート保存時にユーザー情報も追加
tweetsテーブルにuser_idカラムが追加され、
このuser_idカラムに、ツイートを投稿したユーザーのidを保存する処理を記述する。
ツイートを投稿したユーザーとはつまり、現在ログインしているユーザーのこと、
そのため、tweetsテーブルのuser_idカラムに保存すべき値は、current_userのid

ツイートを保存する際、name、image、textというビューから送られてくる情報に加えて、
user_idカラムにログイン中のユーザーのidを保存しなければいけない。
ログイン中のユーザーが持つidを取得するには、current_userメソッドを使用する。


current_userメソッド
Gemのdeviseを導入しているため、使用できるメソッド。
current_userは、現在ログインしているユーザーの情報を取得できる。
現在、ビューから送られてくる情報が入ったparamsと、
current_userメソッドで取得したログイン中ユーザーのidを統合した上で、
ツイートを保存させたいところ。
そこで、2つのハッシュを統合するときに使うmergeメソッドを利用して、
paramsとuser_idの情報を統合できる。

mergeメソッド
ハッシュを結合させるときに使用するRubyのメソッド。
今回は、tweetの情報を持つハッシュと、user_idを持つハッシュを結合さる。
以下の例のように、2つのハッシュを1つにまとめることができる。
【例】
tweet = { name: "たなか", text: "test", image: "test.jpeg" }
uid = { user_id: "1" }
tweet.merge(uid)
=> {:name=>"たなか", :text=>"test", :image=>"test.jpeg", :user_id=>"1"}



アソシエーション
モデル同士を関連付け
ツイートの取得にはTweetモデルを使用し、Tweet.allという記述ができた。
しかし今回のように、ツイートを行なったユーザーの情報を取得するなど、複数のモデルから情報を必要とするケースがある。
複数のモデルで情報を取得しようとすると記述が増え複雑になってしまう。
そこで、テーブル同士で関連付けておき、
一方のモデルからもう一方のモデルにアクセスできるようへするためのアソシエーションという概念がある。

アソシエーションを深ぼる
アソシエーションとは、モデルを利用したテーブル同士の関連付けのこと。
アソシエーションをモデルに定義することで、そのモデルに紐づく別のモデルの情報へアクセスできるようになる。


アソシエーションを定義
has_manyメソッド
Userモデルの視点で考えると、あるユーザーの作成した投稿は複数個ある状態。
つまり、1人のユーザーは複数の投稿を所有している。
この状態のことをhas manyの関係といい、今回の場合は「User has many Tweets」の状態である。
この関連付けをするため、
userと他のモデルとの間に「1対多」のつながりがあることを示すのがhas_manyメソッド。

belongs_toメソッド
1つの投稿は、1人のユーザーが投稿したもの。
つまり1つの投稿を複数人が投稿できないため、投稿は必ず1人のユーザーに所属する。
この状態のことをbelongs toの関係といい、今回の場合は「Tweet belongs to User」の状態である。
Tweetモデルと他のモデル（User）との間に「1対1」のつながりがあることを示すのがbelongs_toメソッド。


※アソシエーションでbelongs_toを指定した場合は、
相手のモデルのid（今回はuser_id）が存在するというバリデーションは不要である。

user_idカラムに対して「空ではないか」というpresence: trueのバリデーションを設ける必要はない。
なぜならアソシエーションでbelongs_toを指定した場合、
相手のモデルのid（今回はuser_id）が「空ではないか」というバリデーションが、
デフォルトでかかるようになっているから。
【例】app/models/tweet.rb
class Tweet < ApplicationRecord
  belongs_to :user
  validates :user_id presence: true ←不要
end

これで、TweetモデルとUserモデル間のアソシエーションが実装できた。



ツイートからユーザー情報も先に読み込む仕組み
N+1問題
N+1問題とは、アソシエーションを利用した場合に限り、データベースへのアクセス回数が多くなってしまう問題。
これはアプリケーションのパフォーマンス低下につながる。
通常、Tweet.allなどでデータを取得する際は、1度のアクセスで済む。
しかし今回のような、ツイートが複数存在する一覧画面に、
それぞれユーザー名を表示するケースを考えてみる。
この場合、tweetsに関連するusersの情報の取得に、ツイート数と同じ回数のアクセスが必要になる。
1億ツイートあれば、1億回以上アクセスすることになり、アプリケーションのパフォーマンスが著しく下がることになる。
これを解決するためには、includesメソッドを利用する。

includesメソッド
includesメソッドは、引数に指定された関連モデルを1度のアクセスでまとめて取得できる。
書き方は、includes(:紐付くモデル名)とします。引数に関連モデルをシンボルで指定する。
【例】
モデル名.includes(:紐付くモデル名)

これにより、N+1問題を解消できる。



tweetsテーブルから不要なカラムを削除
ツイートに「Nickname」という情報を保存しなくなったのでnameカラムも不要になる。
そこで、テーブルからカラムを削除するためのマイグレーションを作成して、カラムの削除を実行する。
のためには、以下のようにコマンドを実行する。
【例】ターミナル
% rails g migration Removeカラム名From削除元テーブル名 削除するカラム名：型

今回は、tweetsテーブルからstring型のnameというカラムを削除する。
tweetsテーブルからnameカラムを削除
ターミナル
# マイグレーションの作成
% rails g migration RemoveNameFromTweets name:string

# マイグレーションの実行
% rails db:migrate

Removeカラム名From削除元テーブル名のカラム名の部分は、
Addカラムの際と同様に必ずしも厳密なカラム名を入力する必要はない。
対して、削除元テーブル名は正確に記述する必要がある！
今回はnameというカラムを削除するので、Nameを含めておく。
末尾のname:stringが、どのカラムを削除するのかを決めているので必ず記述する。

ローカルサーバーを再起動しましょう
カラム情報を変更したため、ローカルサーバーを再起動
ターミナル
# 「control + C」でローカルサーバーを停止

# ローカルサーバーを起動
% rails s



要点チェック
current_userメソッドとは、Gemのdeviseのメソッドで、現在ログインしているユーザーの情報を取得できるメソッドのこと
mergeメソッドとは、ハッシュを結合させるRubyのメソッドのこと
アソシエーションとは、モデルを利用したテーブル同士の関連付けのこと
belongs_toメソッドとは、モデルと他のモデルが「１対１」の関連付けの場合に使用するメソッドで、従属する関連になること
has_manyメソッドとは、モデルと他のモデルが「１対多」の関連付けの場合に使用するメソッドで、所有する関連になること
N+1問題とは、データの取得の際にアクセス過多になってしまう問題のこと
includesメソッドとは、N+1問題を解消できるメソッドのこと


要点チェック
user_signed_in?は、
ユーザーがログインしているか否かを判断できるdeviseが用意しているメソッドのこと

current_userは、
ログインをしているユーザーの情報が取得できるdeviseが用意しているメソッドのこと



ツイートの最新順表示
レコードの取得順を変える。
ツイートを並び替える方法は、
表示のときに順番を変えるのではなく、情報を取得するタイミングで先に並び替える。

orderメソッド
モデルが使用できる、ActiveRecordメソッドの1つ。
orderメソッドは、テーブルから取得してきた複数のレコード情報を持つインスタンスの、並び順を変更するメソッド。
引数には、"並び替えの基準となるカラム名 並び順"のように「並び替えの基準となるカラム名」と「並び順」を半角スペースで繋げて指定する。
orderメソッドは、複数のレコード情報を取得する文に続けて以下のように使用する。
【例】
インスタンス = モデル名.order("並び替えの基準となるカラム名 並び順")

並び順にはそれぞれAscending/Descendingの略でASC（昇順）とDESC（降順）の2種類がある。
並び順        内容
ASC(昇順)     小さいものから大きいものになる。古いものから新しいのものになる
DESC(降順)    ASCの反対

これらのメソッドはコントローラーのアクション内で記述できるメソッド。


要点チェック
orderメソッドとは、ActiveRecordメソッドで、
テーブルから取得してきた複数のレコード情報を持つインスタンスの並び順を変更するメソッドのこと



部分テンプレート
部分テンプレートとは、ビューファイルにおいて繰り返し使用するコードを切り出し、再利用する仕組みのこと。
Rubyでは、繰り返し使うような処理をメソッドとしてまとめていた。これと考え方は同じもの。
複数箇所で使用されている部分に変更があった際でも、1つのファイルの編集だけで済むメリットがある。

今回のアプリ一覧画面では、トップページとマイページでコードが繰り返し使用されている。
Railsでは、繰り返し使用されている部分を_○○.html.erbというファイル名で切り出し、
使用するファイルで割り当てることにより、管理しやすいコードにできる。

_○○.html.erbファイル
部分テンプレートとして切り出すときに作成するファイル。
テンプレート自体のファイル名は、命名規則として、アンダースコア_を先頭に記述する。


_tweet.html.erbファイルが、「ツイート1つ分」のHTML構造を表す部分テンプレートになる。
そのため、複数形のtweetsではなく単数形のtweetになっている点も把握する。
続いて、こちらの部分テンプレートを呼び出すために、renderメソッドを利用する。

renderメソッド
renderメソッドは、部分テンプレートを呼び出す際に利用するメソッド。
呼び出す部分テンプレートは、partialというオプションで指定する。

partialオプション
renderメソッドで使用できるオプション。
partialというオプションを付け、部分テンプレート名を指定することで、該当する部分テンプレートを表示できる。
下の例では、_sample.html.erbという部分テンプレートを呼び出している。
【例】renderメソッドのpartialオプション
# <% render partial: "sample" %>

また、renderメソッドでは、呼び出す部分テンプレートに値を渡すために、localsというオプションを使用できる。

localsオプション
renderメソッドで使用できるオプション。
localsというオプションを付けることで、部分テンプレート内でその変数を使えるようになる。
【例】renderメソッドのlocalsオプション
# <% render partial: "sample", locals: { post: "hello!" } %>

上の記述で、部分テンプレート内においてhello!という文字列の代入されたpostという変数が使えるようになる。


要点チェック
部分テンプレートとは、ビューファイルにおいて繰り返し使用するコードを切り出し、再利用する仕組みのこと
renderメソッドとは、部分テンプレートを呼び出す際に利用するメソッドのこと



コメント機能の実装
コメントは、ツイートが必ず所有する情報ではないため、ツイートと別のテーブルで管理する必要がある。
commentsテーブルを作成。
さらに、コメントはどのツイートに対してのコメントなのか、誰の投稿したコメントなのかが明示されている必要がある。
そのため、userモデルとtweetモデルの2つにアソシエーションを組む必要がある。



ルーティングのネスト
ネストは、ある記述の中に別の記述をして、親子関係を示す方法。「入れ子構造」とも呼ばれる。
ルーティングにおけるネストとは、
あるコントローラーのルーティングの中に、別のコントローラーのルーティングを記述すること。
【例】ルーティングのネスト
Rails.application.routes.draw do
  resources :親となるコントローラー do
    resources :子となるコントローラー
  end
end

ルーティングでネストを利用すると、アクションを実行するためのパスで、親子関係を表現できる。

ルーティングにネストを利用しなければ、
モデルと結びついている別モデルのid情報が送れなくなる。
ネストを利用すれば、id情報を含めることができる。

まとめると、
ルーティングをネストさせる一番の理由は、
アソシエーション先のレコードのidをparamsに追加してコントローラーに送るため。
今回の実装だと、コメントと結びつくツイートのidをparamsに追加する。



検索機能の実装
searchアクションのルーティングを設定
searchという命名で、7つの基本アクション以外のアクションを定義

collectionとmember
collectionとmemberは、ルーティングを設定する際に使用できる。
これを使用すると、生成されるルーティングのURLと実行されるコントローラーを任意にカスタムできる。

collectionはルーティングに:idがつかない、
memberは:idがつくという違いがある。
【例】collectionで定義した場合
Rails.application.routes.draw do
  resources :tweets do
    collection do
      get 'search'
    end
  end
end

【例】collectionのルーティング
Prefix           Verb    URI                                 Pattern
search_tweets    GET    /tweets/search(.:format)              tweets#search

※ルーティングに:idが付いていない

【例】memberで定義した場合
Rails.application.routes.draw do
  resources :tweets do
    member do
      get 'search'
    end
  end
end

【例】memberのルーティング
Prefix           Verb    URI                                 Pattern
search_tweet      GET    /tweets/:id/search(.:format)       tweets#search

URLの指定先が、collectionは:idなし、memberが:idありとなっていることが確認できる。
今回の検索機能の場合、
詳細ページのような:idを指定して特定のページにいく必要がないため、collectionを使用してルーティングを設定する。



モデルに、検索する処理を記述したメソッドを定義する
メソッド名はsearchメソッドとする。
ビジネスロジックとは、データに対する処理などを行うプログラム処理のこと。
具体的には、
「データをどのように処理するのか」
「どのデータを取得するのか」
「どのような手順で処理をしていくのか」などを指す。

searchメソッドをTweetモデルに定義
検索したキーワードが含まれている投稿を取得するために、whereメソッドとLIKE句を利用する。


whereメソッド
モデルが使用できる、ActiveRecordメソッドの1つ。
モデル.where(条件)のように、引数部分に条件を指定することで、
テーブル内の「条件に一致したレコードのインスタンス」を配列の形で取得できる。
引数の条件には、「検索対象となるカラム」を必ず含めて、条件式を記述する。
【例】whereメソッド
モデル.where('検索対象となるカラムを含む条件式')

条件式には'カラム名 > 5'やキーバリューの形でカラム名: 値などの記述が可能。
条件と一致する値を持つレコードを、すべて取得する。
また、whereメソッドを連続して記述することによって、
複数の条件に一致したレコードを取得することもできる。
【例】
# idが3未満のtweetsテーブルのインスタンスを配列で取得
[1] pry(main)> Tweet.where('id < 3')
=> [＃<Tweet id: 1, image: "test1.jpg", text: "いい景色だ。", created_at: "2014-12-06 00:00:00", updated_at: "2014-12-06 00:00:00", user_id: 1>,＃<Tweet id: 2, image: "test2.jpg", text: "Thank you!", created_at: "2014-12-07 00:00:00", updated_at: "2014-12-07 00:00:00", user_id: 2>]

# idが3未満かつuser_idが1のtweetsテーブルのインスタンスを配列で取得
[2] pry(main)> Tweet.where('id < 3').where(user_id: 1)
=> [＃<Tweet id: 1, image: "test1.jpg", text: "いい景色だ。", created_at: "2014-12-06 00:00:00", updated_at: "2014-12-06 00:00:00", user_id: 1>]

これで特定のレコードを取得することができる。
さらに、検索機能にはwhereメソッドに加え、LIKE句を使用する。


LIKE句
LIKE句は、曖昧（あいまい）な文字列の検索をするときに使用するもので、whereメソッドと一緒に使う。
曖昧な文字列の検索とは、
たとえば「1文字目に'a'という文字列が入ったデータ」や
「最後の文字に'b'が入っているデータ」、
「文字列の途中に'c'が入ったデータ」などを検索するもの。

曖昧文字列について
文字列    意味
%	       任意の文字列（空白文字列含む）
_	       任意の1文字

実行サンプル
実行例                         詳細
where('title LIKE(?)', "a%")  aから始まるタイトル
where('title LIKE(?)', "%b")  bで終わるタイトル
where('title LIKE(?)', "%c%") cが含まれるタイトル
where('title LIKE(?)', "d_")  dで始まる2文字のタイトル
where('title LIKE(?)', "_e")  eで終わる2文字のタイトル

whereやLIKE句などの概念は使用する機会がたくさんある。
また、ルーティングに対して、「このパスは可読性が高いか」などの視点を考え、
collectionやmemberもしっかり理解する。

要点チェック
collectionとmemberは、ルーティングを設定する際に使用でき、生成されるURLとコントローラーを任意にカスタムできるメソッドのこと
whereメソッドとは、ActiveRecordメソッドに属し、データを取得する際に条件をつけられるメソッドのこと
曖昧な文字列の検索をする際は、LIKE句を用いること



テストを知る
アプリの挙動確認
自動でアプリの挙動を確認する
動作を確認するためのコードを書き、そのコードを実行して自動で確認するという方法。
こうしたコードをテストコードという。

テストコード
アプリケーション内に記述する、そのアプリケーションの挙動を確認するためのコードのこと。

Ruby on Railsにおけるテストコード
RSpec
RSpec（アールスペック）は、Ruby on Railsのテストコードを書くために用いられるGem。
公式のGitHubページを確認：rspec-rails


テストコードのパターンと種類
テストコードを書くべきパターン
アプリケーションの挙動を確認するときは、「うまくいくとき」「うまくいかないとき」をそれぞれ確認する必要がある。

PicTweetの投稿機能における「うまくいくとき」は、
「画像URLとテキストの両方を入力して送信すると、ツイートがテーブルに保存できる」というケース
一方で、「うまくいかないとき」は、
「画像URLもテキストも入力せずに送信ボタンを押すと、ツイートはテーブルに保存されない」というケース
テストコード書く際は、前者を正常系、後者を異常系と呼ぶ。

正常系
「ユーザーが開発者の意図する操作を行った時の挙動」を確認するテストコードが、正常系に分類される。

異常系
「ユーザーが開発者の意図しない操作を行った時の挙動」を確認するテストコードが、異常系に分類される。
たとえば、必須項目を入力せずに送信した際は、「必須項目を入力してください」とアラート画面などがでる。
この挙動を確認することは異常系に分類される。


テストコードの種類
テストコードの種類は、大きく2つある。
1つ目が、実装した機能を部分的に意図通りに動作するか確認する単体テスト。
2つ目が、ユーザーがその機能を使う際、一連の動作が問題なく行われるかを確認する結合テスト。

単体テストコード
モデルやコントローラーなどの機能ごとに問題がないか確かめる。
たとえば、PicTweetにおけるTweetモデルのテストコードでは
「画像URLとテキストがない投稿は、テーブルに保存させない」というバリデーションの挙動を確認する。

結合テストコード
ユーザーがブラウザで操作する一連の流れを再現して、問題がないか確かめる。
たとえば、PicTweetにおけるツイート投稿のテストコードでは
「画像URLとテキストを投稿して送信ボタンを押すと、投稿完了ページに移動し、
TOPページに戻るとさきほど投稿した内容が表示されている」という流れを一気に確かめる。

要点チェック
アプリケーションの挙動はテストコードを実行することで確認できること
Ruby on Railsでテストコードを書く際は、RSpecを使用することが多いこと
テストコードを書くことで、アプリケーションの品質が担保されるだけではなく、設計を読み解くこともできること
テストコードは正常系と異常系に大きく分類されること
テストコードは、単体テストコードと、結合テストコードの2種類があること



Gemを追加
RSpecのGemをPicTweetに導入
Gemfile
group :development, :test do
  # Call 'byebug' anywhere in the code to stop execution and get a debugger console
  gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]
  gem 'rspec-rails', '~> 4.0.0'  # これを追記
end

group :development, :testというグループの中に記述。
そうすることで、Gemの動作に制限をもたせる。


bundle installを実行
ターミナル
% cd ~/projects/pictweet #PicTweetのディレクトリへ移動
% bundle install


RSpecの設定
アプリケーション内でRSpecを使用するための設定
PicTweetにRSpecをインストール
ターミナル
% rails g rspec:install

インストールが完了すると、以下のようにディレクトリやファイルが生成される。
【例】ターミナル
create  .rspec
create  spec
create  spec/spec_helper.rb
create  spec/rails_helper.rb

.rspecに設定を追加
生成された.rspecファイルを開き、以下のように記述。
この記述は、テストコードの結果をターミナル上に可視化するための記述。
.rspec
--require spec_helper
--format documentation # これを追加

これでRSpecの設定は完了


テストコードを記述するファイルを用意
コマンドでファイルを生成することで、テストコードの雛形があらかじめ記載されたファイルを生成することができる。
ターミナル
% rails g rspec:model user

以下のように表示されていれば、ファイルは生成されている。
【例】
create  spec/models/user_spec.rb

生成されたファイルの1行目に、以下の記述があることを確認する。
spec/models/user_spec.rb
require 'rails_helper'  # ここを確認する

RSpec.describe User, type: :model do
  pending "add some examples to (or delete) #{__FILE__}"
end

RSpecでモデル、ビュー、コントローラーのテストを行うためには、rails_helper.rbというファイルを読み込む必要がある。
require 'rails_helper'と記述することで、ファイルを読み込んでくれる。


rails_helper
Rspecを用いてRailsの機能をテストするときに、共通の設定を書いておくファイル。
各テスト用ファイルでspec/rails_helper.rbを読み込むことで、共通の設定やメソッドを適用する。
rails gコマンドでテストファイルを生成すると、rails_helperを読み込む記述が、自動的追加される。



テストコードの雛形を記述
これから実装するテストコードで「どの機能に対してのテスト行うか」を明記する。
この場合、RSpecにおいてはdescribeメソッドを使用する。

describe（ディスクライブ）
describeとは、テストコードのグループ分けを行うメソッド。
「どの機能に対してのテストを行うか」をdescribeでグループ分けし、その中に各テストコードを記述する。
describeにつづくdo~endの間に、さらにdescribeメソッドを記述することで、入れ子構造をとることもできる。
describeメソッドを用いて、「ユーザー新規登録」についてのテストを行うことを記述する。

describeメソッドを用いてテスト内容を記述
spec/models/user_spec.rb
require 'rails_helper'

RSpec.describe User, type: :model do
  # 記述
  describe 'ユーザー新規登録' do
    # ユーザー新規登録についてのテストコードを記述します  
  end
end

上記のように記述することで、「どの機能に対してのテスト行うか」を明記する。
次に、itメソッドを用いて、より詳細なグループ分けを行う。


it（イット）
itメソッドは、describeメソッド同様に、グループ分けを行うメソッド。
itの場合はより詳細に、「describeメソッドに記述した機能において、どのような状況のテストを行うか」を明記する。
また、itメソッドで分けたグループを、exampleとも呼ぶ。

example（イグザンプル）
exampleとは、itで分けたグループのことを指す。
また、itに記述した内容のことを指す場合もある。


nicknameが空の場合の記述
異常系のモデル単体テストの実装は、以下の流れで進み
1,保存するデータ（インスタンス）を作成する
2,作成したデータ（インスタンス）が、保存されるかどうかを確認する
3,保存されない場合、生成されるエラーメッセージが想定されるものかどうかを確認する
nicknameとemailのテスト実装を通して、この流れを理解

nicknameの値が空のインスタンスを生成
nicknameに設定されているpresence: tureが正常に機能するか検証するため、
バリデーションを実行します。バリデーションはDBに保存する前しか実行されません。
そこで、valid?メソッドを用いて、任意のタイミングでバリデーションを実行しましょう。


valid?
valid?は、バリデーションを実行させて、エラーがあるかどうかを判断するメソッド。
エラーがない場合はtrueを、ある場合はfalseを返します。
また、エラーがあると判断された場合は、エラーの内容を示すエラーメッセージを生成。

nicknameが空のインスタンスuserに、valid?メソッドを使用しています。
Userモデルのバリデーションにはpresence: trueが指定されているため、
nicknameが空ではDBに保存できないと判断され、valid?メソッドはfalseを返すはずです。

上記のような「想定した挙動」と「アプリの実際の挙動」を確認します。
この確認をテストコードに落とし込んだものをexpectationといいます。

expectation（エクスペクテーション）
エクスペクテーションとは、検証で得られた挙動が想定通りなのかを確認する構文のこと。
expect().to matcher()を雛形に、テストの内容に応じて引数やmatcherを変えて記述します。

matcher（マッチャ）
matcherは、「expectの引数」と「想定した挙動」が一致しているかどうかを判断します。
expectの引数には検証で得られた実際の挙動を指定し、マッチャには、どのような挙動を想定しているかを記述します。

代表的な2つのincludeとeqマッチャを紹介します。

include
includeは、「expectの引数」に「includeの引数」が含まれていることを確認するマッチャです。

具体的には、以下のように記述します。

【例】includeマッチャのテストコード
describe 'フルーツ盛り合わせ' do
  it 'フルーツ盛り合わせにメロンが含まれている' do
    expect(['りんご', 'バナナ', 'ぶどう', 'メロン']).to include('メロン')
  end
end

このように記述することで、
りんご、バナナ、ぶどう、メロンが入った配列に、メロンが含まれることを想定しています。

このテストコードを実行した場合、
想定通り配列のなかにメロンは含まれているため、テストは成功します。

eq
eqは、「expectの引数」と「eqの引数」が等しいことを確認するマッチャです。
具体的には、以下のように記述します。

【例】eqマッチャのテストコード
describe '加算' do
  it '1 + 1の計算結果は2と等しい' do
    expect(1 + 1).to eq(2)
  end
end

このように記述することで、1 + 1という計算の結果が、2と等しいことを想定しています。
このテストコードを実行した場合、想定通り1 + 1は2と等しいため、テストは成功します。
以上の例をふまえて、今回行っているテストのエクスペクテーションを考えましょう。

Userモデルで、nicknameにはpresence: trueのバリデーションを設けています。
このバリデーションが正しく機能していれば、
valid?メソッドを実行したときにfalseが返ってくるはずです。
falseが返ってくるということはDBに保存できないと判断されたため、
インスタンスにはエラーの内容を示す情報が生成されます。
errorsメソッドを用いてエラーの内容を確認してみましょう。

errors
errorsは、インスタンスにエラーを示す情報がある場合、その内容を返すメソッド。

full_messages
full_messagesは、エラーの内容から、エラーメッセージを配列として取り出すメソッドです。

ターミナルでuser.errors.full_messagesと実行すると、以下のようにエラーの内容の配列が返されます。

【例】ターミナル
# 上記の例に続けて以下を実行すると、エラーメッセージが表示される
[4] pry(main)> user.errors.full_messages
=> ["Nickname can't be blank"]

以上のことをふまえて、どのようなエクスペクテーションを記述すればよいのか考えます。

expectの引数には検証で得られた挙動を指定したいため、valid?メソッドを使用した後のインスタンスのエラーメッセージを指定しましょう。
すなわち、expect(user.errors.full_messages)となります。

さらに、full_messagesの返り値は配列であるため、includeマッチャを用いて、
配列にどのようなエラーが含まれていればよいか指定します。

nicknameでpresence: trueによるエラーが起こるはずであるため、
想定するエラーメッセージは"Nickname can't be blank"が適切です。

要点チェック
describeとは、「どの機能に対してテストを行うかを明示したグループ」を作成するメソッドであること
itとは、「どのような状況のテストを行うかを明示したグループ」を作成するメソッドであること
exampleとは、itで作成したグループのこと
テストコードの実行は、bundle exec rspecコマンドを使用すること
異常系のテストでは、実際に出力されるエラーメッセージが、想定通りの内容か確認をすること
エラーメッセージの確認には、エクスペクテーションと呼ばれるテストコードを用いること
errors.full_messagesメソッドでエラーメッセージの配列を出力できること


インスタンスを生成するコードの分離
これまで書いたテストコードでは、
user = User.new(nickname: '', email: 'test@example', password: '000000', password_confirmation: '000000')
のようにユーザーを生成する記述を都度記述していました。
これらの同じような記述はまとめてしまった方が効率的です。
その時に使用するものが、FactoryBotです。

FactoryBot
インスタンスをまとめることができるGemです。
他のファイルであらかじめ各クラスのインスタンスに定める値を設定しておき、
各テストコードで使用します。


共通した記述を切り出そう
beforeを使う
【例】
require 'rails_helper'
RSpec.describe User, type: :model do
  before do
    # 何かしらの処理
  end

  describe 'X' do
    it 'Y' do
      # before内の処理が完了してから実行される
    end
    it 'Z' do
      # before内の処理が完了してから実行される
    end
  end
end

ただし、変数を受け渡す際は、beforeに定義する変数はインスタンス変数にする必要があります。


ランダムな値の出力
ここまでで、FactoryBotやbeforeをつかって、
テストコードをスッキリとまとめることができました。
しかし、もう1つ対応しなければならないことがあります。

FactoryBotで設定した値は、'test@example'など固有のものでした。
しかし、これから複数のテストを行う際に、
「すでにemailの重複したインスタンスが存在する」といったような意図しない形で弾かれてしまうことがあります。
beforeでインスタンスを生成する都度、値をランダムで生成したいところです。その際に役立つものがFakerです。

Faker
ランダムな値を生成するGemです。メールアドレス、人名、パスワードなど、さまざまな意図に応じたランダムな値を生成してくれます。

要点チェック
FactoryBotのGemを使用すると、インスタンスをまとめることができること
buildを使用すると、インスタンスの生成ができること
beforeを使用すると、すべてのテストコードが実行する前にセットアップを行うことができること
FakerのGemを使用すると、メールアドレス、人名、パスワードなどをランダムな値で生成できること


要点チェック
contextとは、「テストを行いたい特定の条件」を記述するメソッドであること
be_validとは、バリデーション実行時の返り値がtrueであることを確かめるマッチャであること


コントローラーの単体テストコード
テストコードの種類	テストコードを書く方針
モデル	インスタンスを生成し、それがモデルに規定したどおりの挙動になるか（たとえば、バリデーションが正しく働くか）を確かめる
コントローラー	あるアクションにリクエストを送ったとき、想定通りのレスポンスが生成されるかどうかを確かめる

コントローラーのテストコードでは、
「リクエストとレスポンス」に着目したテストコードを記述します。
この時に、RSpecの中でもRequest Specと呼ばれる手法を利用します。

Request Spec
RSpecが提供している、コントローラーのテストコードを書くために特化した手法です。
RSpecの導入が完了していれば使用できます。

なお、コントローラーのテストコードは、
次章で学ぶ結合テストコードに記述する内容と、同じような責務を果たすことが多いです。
したがって、本章では簡単に限られたコントローラーの機能を確認することにします。

create
ActiveRecordのcreateメソッドと同様の意味を持ちます。
buildとほぼ同じ働きをしますが、createの場合はテスト用のDBに値が保存されます。
注意すべき点として、1回のテストが実行され、終了する毎にテスト用のDBの内容がロールバックされます。（保存された値がすべて消去されてしまう）

それでは、各exampleをコードに落とし込みましょう。



正常にレスポンスが返ってくることを確かめよう
まず、「indexアクションにリクエストすると正常にレスポンスが返ってくる」ことを確かめます。
テストコードにおいては最初に、「indexアクションにリクエストすると」を行う記述をします。
その時に使用するものがgetです。

get
get 〇〇_pathのように、
どこのパスにリクエストを送りたいかを記述します。
どのアクションがどのパスに対応しているかは、
以下のようにrails routesコマンドで確かめることはすでに学習済みです。
【例】ターミナル
% rails routes

Prefix          Verb    URIPattern                    Controller#Action
root            GET     /                             tweets#index
tweet_comments  POST    /tweets/:tweet_id/comments    comments#create
search_tweets   GET     /tweets/search                tweets#search
tweets          GET     /tweets                       tweets#index
                POST    /tweets                       tweets#create
new_tweet       GET     /tweets/new                   tweets#new

#前後省略

今回はindexアクションにリクエストを送るため、get root_pathとすると良いでしょう。


response
リクエストに対するレスポンスそのものが含まれます。
このレスポンスで取得できる情報に、想定する内容が含まれているかを確認することで、
テストコードを書くことができます。


レスポンスを確認しましょう
binding.pryで停止しているところに、
responseと入力してエンターキーを押下しましょう。
するとレスポンスとしてたくさんの情報が表示されるはずです。
ターミナル

=> #<ActionDispatch::TestResponse:0x00007fe4ba5b45e0
@cache_control={:max_age=>"0", :private=>true, :must_revalidate=>true},
@committed=false,
@cv=#<MonitorMixin::ConditionVariable:0x00007fe4ba5b44a0 @cond=#<Thread::ConditionVariable:0x00007fe4ba5b4478>, @monitor=#<ActionDispatch::TestResponse:0x00007fe4ba5b45e0 ...>>,
@header=
{"X-Frame-Options"=>"SAMEORIGIN",
  "X-XSS-Protection"=>"1; mode=block",
  "X-Content-Type-Options"=>"nosniff",
  "X-Download-Options"=>"noopen",
  "X-Permitted-Cross-Domain-Policies"=>"none",
  "Referrer-Policy"=>"strict-origin-when-cross-origin",
  "Content-Type"=>"text/html; charset=utf-8",
  "ETag"=>"W/\"07b471bc4b0f822d1d74886c0cd36998\"",
  "Cache-Control"=>"max-age=0, private, must-revalidate",
  "X-Request-Id"=>"e0aea9ae-5622-4a8a-9cfc-13fa1eaaddf3",
  "X-Runtime"=>"2.913438",
  "Content-Length"=>"154958"},
@mon_count=0,
@mon_mutex=#<Thread::Mutex:0x00007fe4ba5b4590>,
@mon_mutex_owner_object_id=70310177907440,
@mon_owner=nil,

#以下省略
長過ぎるため一度に表示されません。
十字キーの↓を入力すると続きを確認できます。
Qを押下すると終了して次の入力画面に移行できます。

ここから、「正常なレスポンスかどうか」を判断する必要があります。
それを判断するためには、HTTPステータスコードで判別します。


HTTPステータスコード
HTTP通信において、どのような処理の結果となったのかを示すものです。以下のような分類になっています。
ステータスコード	 内容
100~	          処理の継続中
200~	          処理の成功
300~	          リダイレクト
400~	          クライアントのエラー
500~	          サーバーのエラー

今回は正常にレスポンスを得ることを確かめたいため、200というステータスコードを期待します。
レスポンスの中からステータスコードを確かめるためには、statusを利用します。


status
response.statusと実行することによって、そのレスポンスのステータスコードを出力できます。


ステータスコードを確認しましょう
binding.pryで停止しているところに、
response.statusと入力してエンターキーを押下しましょう。
するとレスポンスのステータスコードが出力されます。
ターミナル
[2] pry(#<RSpec::ExampleGroups::TweetsController::GETIndex>)> response.status
=> 200

上記のように、200が確認できれば成功です。
上記を踏まえて、正常なレスポンスが返ってくることを確かめるテストコードを記述しましょう。


投稿済みのツイートがレスポンスに含まれることを確認しよう
続いて、「レスポンスに投稿済みのツイートのテキストが存在する」を確かめるテストコードを記述します。
先ほど学んだresponseの中に、ブラウザ上に表示される記述があります。それはbodyと呼ばれます。

body
response.bodyと記述すると、ブラウザに表示されるHTMLの情報を抜き出すことができます。


要点チェック
Request Specはコントローラーのテストコードを書くことに特化している手法であること
getでリクエストを送りたいパスを指定すること
responseにリクエストに対するレスポンスが含まれること
response.statusでステータスコードの確認が出来ること
bodyとは、ブラウザに表示されているHTML情報のこと



結合テストコードの概要
結合テストコードを実行するためには、System Specという技術を使用します。

System Spec
System Spec（システムスペック）は結合テストコードを記述するための仕組みのことを言います。
大枠の記述はこれまでのRSpecと変わりません。

System Specを記述するためには、CapybaraというGemを用います。
これはすでにデフォルトでRuby on Railsに搭載されています。


Capybara
Capybara（カピバラ）はSystem Specを記述するために必要なGemです。
以下のようにGemfileに標準で記載されています。すなわち導入済みです。
【例】Gemfile
group :test do
  # Adds support for Capybara system testing and selenium driver
  gem 'capybara', '>= 2.15'
  gem 'selenium-webdriver'
  # Easy installation and use of web drivers to run system tests with browsers
  gem 'webdrivers'
end


新規登録がうまくいくときのテストコード
visit
visit 〇〇_pathのように記述すると、〇〇のページへ遷移することを表現できます。
RequestSpecで学んだgetと似ていますが、
getはあくまでリクエストを送るだけのことを意味し、
visitはそのページへ実際に遷移することを意味します。

続いて、
「トップページにサインアップページへ遷移するボタンがあることを確認する」へ取り組みます。
訪れたページ上にその文言があるかどうかは、
現状のページを意味するpageに対してhave_contentマッチャを用いて判断します。


page
visitで訪れた先のページの見える分だけの情報が格納されています。
後述するとおり、「ログアウト」などのカーソルを合わせてはじめて見ることができる文字列はpageの中に含まれません。

have_content
expect(page).to have_content('X')と記述すると、
visitで訪れたpageの中に、Xという文字列があるかどうかを判断するマッチャです。

続いて、
「新規登録ページへ移動する」と「ユーザー情報を入力する」を考えます。
前者はトップページに移動したときと同様であるため、説明は割愛します。

後者の「ユーザー情報を入力する」では、
実際にブラウザ上で文字列を入力することを再現する必要があります。
この時に使用するものがfill_inです。


fill_in
fill_in 'フォームの名前',
with: '入力する文字列'のように記述することで、
フォームへの入力を行うことができます。
それでは、フォームの名前はどのように知ることができるのでしょうか。
その時に使用するものが、検証ツールです。


検証ツール
ブラウザに標準で備わっている、HTMLの要素や、
適用されているCSSのコードを確認することができる機能です。
ブラウザで右クリックし、「検証」をクリックすると表示できます。

続いて、新規登録ページで、左上の選択アイコンをクリックし、
フォームにカーソルをあわせます。
すると、各フォームがlabelで紐付いていることがわかります。
具体的には、label要素のforに指定されているIDと、inputのidの値が同一になっています。

この場合、フォームの名前はそれぞれ「Nickname」「Email」「Password」「Password confirmation」とわかります。
それでは、fill_inを使ってテストコードを記述しましょう。

ちなみに、ラベルとフォームが正しく紐付いている場合、
以下のようにラベル名をクリックするとそのフォームが特定できます。

続いて、「サインアップボタンを押すとユーザーモデルのカウントが1上がることを確認する」へ取り組みます。
まずは「サインアップボタンを押すと」の部分を考えましょう。
この時に使用するものがfind().clickです。


find().click
find('クリックしたい要素').clickと記述することで、
実際にクリックができます。検証ツールを開いて、クリックしたい要素を確認しましょう。
<input type="submit" name="commit" value="Sign up" data-disable-with="Sign up">となっていることから、こちらを指定すれば良さそうです。
この時に、input要素のname属性を指定します。その場合、find('input[name="commit"]').clickという記述になります。

続いて、「ユーザーモデルのカウントが1上がる」、すなわちユーザーが登録されてレコードが1つ増えることを確認します。
その時に用いるものが、changeマッチャです。

change
expect{ 何かしらの動作 }.to change { モデル名.count }.by(1)と記述することによって、
モデルのレコードの数がいくつ変動するのかを確認できます。
changeマッチャでモデルのカウントをする場合のみ、expect()ではなくexpect{}となります。
「何かしらの動作」の部分には、「送信ボタンをクリックした時」が入ります。
すなわち、find('input[name="commit"]').clickが入ります。
次に、「トップページへ遷移したことを確認する」へ取り組みます。
新規登録が完了すると、自動的にトップページへリダイレクトされます。
したがって、今いるページのパスがトップページであることを確かめたいです。
その時に使用するものが、current_pathです。

current_path
文字通り、現在いるページのパスを示します。
expect(current_path).to eq(root_path)と記述すれば、
今いるページがroot_pathであることを確認できます。

次に、「カーソルを合わせるとログアウトボタンが表示されることを確認する」へ取り組みましょう。
新規登録が完了してログイン状態になれば、
ヘッダーにはログアウトボタンが表示されます。
しかし、ログアウトボタンは自身のニックネーム部分にカーソルをあわせないと表示されません。
この時の動作は、hoverと言い、RSpecでも同様のメソッドを用いることができます。

hover
find('ブラウザ上の要素').hoverとすることで、
特定の要素にカーソルをあわせたときの動作を再現できます。
ログアウトボタンはヘッダーの中のspan要素をhoverすることで現れます。
しかし、span要素は他でも使われているため、その親要素のuser_navクラスもあわせて指定します。

最後に、「サインアップページへ遷移するボタンや、
ログインページへ遷移するボタンが表示されていないことを確認する」へ取り組みます。
新規登録が正しくできていればログイン状態になるため、これらのボタンは存在しないはずです。
存在しない事を確かめるために、have_no_contentを用います。

have_no_content
have_contentの逆で、文字列が存在しないことを確かめるマッチャです。

これで新規登録がうまくいくときの結合テストコードが記述できました。テストコードを実行して確かめましょう。

要点チェック
System Specを記述するためには、CapybaraというGemが必要であること
visitで実際にアクセスしたいページに遷移できること
pageは、visitで訪れた先のページの見える分だけの情報が格納されていること
have_contentはvisitで訪れたpageの中に取得したい文字列があるかどうかを判断できること
検証ツールでフォームの名前を取得して、fill_inを用いて文字列を入力することができること
find().clickはクリックしたい要素を指定することで、実際にクリックすることができること
changeはモデルのレコードの数がいくつ変動するのかを確認できること
hoverで、特定の要素にカーソルをあわせたときの動作を再現できること



ユーザーログインの結合テストコード
exampleを整理しよう
ユーザーログインができるとき、できないときを考えると、以下のようにexampleとその中での挙動を洗い出すことができます。

ログインができるとき
保存されているユーザーの情報と合致すればログインができる
トップページに移動する
トップページにログインページへ遷移するボタンがあることを確認する
ログインページへ遷移する
正しいユーザー情報を入力する
ログインボタンを押す
トップページへ遷移したことを確認する
カーソルを合わせるとログアウトボタンが表示されることを確認する
サインアップページへ遷移するボタンやログインページへ遷移するボタンが表示されていないことを確認する
ログインができないとき
保存されているユーザーの情報と合致しないとログインができない
トップページに移動する
トップページにログインページへ遷移するボタンがあることを確認する
ログインページへ遷移する
ユーザー情報を入力する
ログインボタンを押す
ログインページへ戻されることを確認する

ポイントとしては、beforeの記述です。
ユーザー新規登録の時はユーザー情報の生成のみを行うためFactoryBot.build(:user)としていました。
一方、今回はログイン、
すなわちすでに登録されているユーザーに対しての挙動を確認するためFactoryBot.create(:user)としています。



have_selector
指定したセレクタが存在するかどうかを判断するマッチャです。
have_selector ".content_post[style='background-image: url(#{@tweet_image});']"という形で記述できます。


have_link
expect('要素').to have_link 'ボタンの文字列', href: 'リンク先のパス'
と記述することで、要素の中に当てはまるリンクがあることを確認できます。
have_linkはa要素に対して用います。


have_no_link
have_linkの逆で、当てはまるリンクがないことを確認します。
expect('要素').to have_no_link 'ボタンの文字列', href: 'リンク先のパス'
と記述することで、要素の中に当てはまるリンクがないことを確認できます。

さて、今回のテストコードでは「編集」へのリンクのある/なしを確認します。
PicTweetにおいて編集ボタンは以下のようにカーソルを合わせることで表示されます。
このような要素に対しては、hoverを用いることはすでに学びました。
しかし、PicTweetにおいてこのhoverすべきクラスは.moreですが、
下図のように同じクラス名が複数存在します。

all
all('クラス名')でpageに存在する同名のクラスを持つ要素をまとめて取得できます。
そしてall('クラス名')[0]のように添字を加えることで「◯番目のmoreクラス」を取得できます。


find_link().click
a要素で表示されているリンクをクリックするために用います。
find_link('リンクの文字列', href: 'URL').clickといった形で使います。
find().clickと似ていますが、find_link().clickはa要素のみに対して用いることができます。


要点チェック
have_selectorを使用すると、指定したセレクタが存在するか判断できること
have_linkを使用すると、要素の中に当てはまるリンクがあることを確認できること
allを使用すると、pageに存在する同名のクラスを持つ要素をまとめて取得できること
find_link().clickを使用すると、a要素で表示されているリンクをクリックできること



日本語対応をする
アプリケーションのエラーメッセージを日本語化しよう

概要
本章では、PicTweetを例に、
ユーザー登録やツイート投稿画面の入力フォームが空だった場合に表示されるエラーメッセージを、
英語から日本語に変換する方法を学びます。
どのような設定、記述を行うと日本語のエラーメッセージに変換されるのかを、順を追って説明していきます。


目的
エラーメッセージの表示方法を学ぶこと
ファイルの言語設定について理解すること
英語を日本語に変換する方法を学ぶこと


事前準備
事前準備として、PicTweetを例に、まずは英語でエラーメッセージを表示させる機能を実装していきます。
現状、投稿画面とログイン画面は、
入力フォームが空だった場合にエラー内容が何も表示されない仕様になっていますので、
エラーメッセージを表示させる記述をしていきます。


投稿画面を編集
投稿画面で画像とテキストに何も入力せず投稿した場合に、エラーメッセージが表示される設定

モデルを編集
テキストに加え、画像も空では投稿できないように、バリデーションを追記
app/models/tweet.rb
class Tweet < ApplicationRecord
  belongs_to :user
  has_many :comments 

  # imageも空で投稿できないように追記
  validates :text, :image, presence: true

  # 以下省略

end


コントローラーを編集
createアクションの中にツイートが保存される場合の条件分岐を追記します。
@tweetを定義し、valild?メソッドを使用してツイートが保存されなければ、newへ戻る記述をします。

app/controllers/tweets_controller.rb
#中略
def create
  @tweet = Tweet.new(tweet_params)
  #バリデーションで問題があれば、保存はされず「投稿画面」に戻る
  if @tweet.valid?
    @tweet.save
    redirect_to root_path
  else
    #保存されなければ、newに戻る
    render 'new'
  end
end


ビューを編集しましょう
エラーメッセージのビューを作成します。
views/layoutsの下に_error_messages.html.erbファイルを自作しましょう。

どのモデルのバリデーションにも対応できるように、if文にmodel.errors.any? を記述します。
app/views/layouts/_error_messages.html.erb
<% if model.errors.any? %>
  <div class="error-alert">
  <ul>
    <% model.errors.full_messages.each do |message| %>
    <li class='error-message'><%= message %></li>
    <% end %>
  </ul>
  </div>
# <% end %>


次に、エラーメッセージを表示させる部分に以下のような記述をしましょう。
ツイートが保存されなかった場合、
# <%= render 'layouts/error_messages', model: form.object %>が読み込まれエラーメッセージが表示されます。

app/views/tweets/new.html.erb
<div class="contents row">
  <div class="container">
    <%= form_with(model: @tweet, local: true) do |form| %>
      <h3>
        投稿する
      </h3>
      <%= render 'layouts/error_messages', model: form.object %>
      <%= render partial: "form", locals: { form: form } %>
    <% end %>
  </div>
</div>


ここまでで、投稿画面で画像とテキストを何も入力せず投稿した場合に、
エラーメッセージが表示される設定が完了しました。



Tweetのログイン画面を編集
次に、ログイン画面です。
ログイン画面で、EmailとPasswordに何も入力せず投稿した場合にエラーメッセージが表示される設定を、
以下の手順に沿って実装していきましょう。

新規登録には、deviseの機能で初めからエラーメッセージが表示される機能が備わっています。
ビューを編集しましょう
devise/sessions/new.html.erbを以下のように編集
app/views/devise/sessions/new.html.erb
<%# ログイン時のエラーメッセージ  %>
<div class="contents row">
  <div class="container">
    <h2>Log in</h2>
    # <div class='login-flash-message'>
    #   <%= flash[:notice] %>
    #   <%= flash[:alert] %>
    # </div>
    # <%= form_with model: @user, url: user_session_path, id: 'new_user', class: 'new_user', local: true do |f| %>

    中略

これで事前準備は完了


現状を確認
編集が完了したので、エラーメッセージが表示されるか確認してみましょう。

ブラウザで確認
サーバーを起動し、localhost:3000に接続して、
それぞれの画面でフォームに何も入力せず送信ボタンを押した場合の挙動を確かめてみましょう。


エラーメッセージの日本語化
日本語化の設定をしよう
英語から日本語に変える設定を行っていきます。
どのような設定、記述をすれば日本語表示に変わるのか、順を追ってブラウザで確かめていきましょう。


日本語の言語設定を行いましょう
application.rbを編集して、言語設定を変更しましょう。
:jaは日本語設定にするという意味です。

config/application.rb
# 中略
module Pictweet
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 6.0

    # 日本語の言語設定
    config.i18n.default_locale = :ja
      # 省略
    end
end


Gemfileを編集しましょう
日本語に対応する"rails-i18n"というGemを導入します。

rails-i18n

このGemの導入によって、下記サイトに記述してある日本語を使えるようになっています。
どのような文言が日本語に翻訳してあるのか確認してみましょう。

rails-i18nに登録されている日本語
https://github.com/svenfuchs/rails-i18n/blob/master/rails/locale/ja.yml

Gemfile
#中略
gem 'rails-i18n'


続いて、以下のコマンドを実行しましょう。
ターミナル
bundle install

上の作業で、
application.rbにconfig.i18n.default_locale = :jaの記述をしないと日本語で反映されないので、
忘れずに設定しましょう。


日本語化用のファイルを作成しよう
エラーメッセージを全て日本語にするためには、
もう一つファイルを用意する必要があります。
そのファイルのことをlocaleファイルと言います。


localeファイル
locale（ロケール）ファイルとは、様々な言語に対応できる言語ファイルです。
localeファイルの中に日本語化用のファイルを作成することで、英語を日本語に翻訳してくれます。
そして、その日本語へ翻訳するためのファイルは、通常YAMLというファイル形式を用います。


YAML
YAMLとは、ファイルの書き方のルールの一つで、
中身が文字だけで記述されてるテキストファイルです。
database.ymlもこれに当てはまり、データベースの接続に必要な設定が記述してあります。

デフォルトでは、下記の例のように「英語」でYAMLファイルが書かれていますので、
先程のエラーメッセージが英語で表示されます。

【例】config/locales/devise.en.yml
en:
  devise:
    confirmations:
      confirmed: "Your email address has been successfully confirmed."
      send_instructions: "You will receive an email with instructions for how to confirm your email address in a few minutes."
   errors:
     messages:
       already_confirmed: "was already confirmed, please try signing in"
       not_found: "not found"

では次から「英語」から「日本語」に変換するために、日本語化用のYAMLファイルを導入しましょう。
まずは、新規登録時とログイン時のエラーメッセージを日本語にするファイルを準備します。

devise.ja.ymlを作成しましょう
config/localesディレクトリに、devise.ja.ymlというファイルを作成します。

config 　
  locales
    devise.ja.yml
下記のサイトに記述内容が掲載されているので、
丸ごとコピーして作成したdevise.ja.ymlの中に貼り付けましょう。

ymlファイルは、インデントにミスがあるとエラーが生じます。
コードを貼り付けた後、インデントにミスがないか必ず確認しましょう。
devise.ja.yml
https://github.com/tigrish/devise-i18n/blob/master/rails/locales/ja.yml


ブラウザで確認しましょう
ブラウザで確認する前に、サーバーを再起動しましょう。
再起動後、localhost:3000に接続してそれぞれの画面で、
フォームに何も入力せず送信ボタンを押した場合の挙動を確かめてみましょう。


この段階で、ログイン画面は、全て日本語のエラーメッセージが表示されるようになりました。
しかし、新規登録画面ではNicknameを入力してくださいと表示されており、
Nicknameだけが英語になっています。

日本語に翻訳する文言を確認しましょう
先ほどブラウザで確認した通り、
新規登録画面はNicknameを入力してくださいと表示されています。
また、投稿画面はTextを入力してください、Imageを入力してくださいと表示されます。
このNickname、Text、Imageは、
Gem 'rails-i18n'やdevise.ja.ymlを導入したことによって使える日本語に含まれていないので、
英語で表示されてしまいます。
したがって、これらを翻訳するファイルを手動で作成していきます。


ja.ymlを作成しましょう
config/localesディレクトリに、ja.ymlというファイルを作成します。

config
  locales
    devise.ja.yml
    ja.yml

ファイルを作成したら、以下の記述をしましょう。
config/locales/ja.yml
ja:
  activerecord:
    attributes:
      user:
        nickname: ニックネーム
      tweet:
        text: テキスト
        image: 画像

この記述で、Nickname、Text、Imageが日本語に翻訳されます。

ブラウザで確認しましょう
ブラウザで確認する前に、サーバーを再起動しましょう。
再起動後、localhost:3000に接続してそれぞれの画面で、
フォームに何も入力せず送信ボタンを押した場合の挙動を確かめてみましょう。


ここまでの設定や記述によって、
新規登録画面、ログイン画面、投稿画面の全てのエラーメッセージが日本語で表示されるようになりました。



テストコードの書き換え
エラーメッセージ を日本語に変更したということは、
単体テストコードの中で使用している期待するエラーメッセージも日本語に変わるので、
そちらも変更しましょう。

現状のテストコードを確かめよう
エラーメッセージが日本語に変わったということは、
現状のテストコードではうまく検証ができません。
現状のテストコードは英語のエラーメッセージが出現する前提で記述しているためです。

両モデルのエラーの原因は同じです。
原因を説明すると、エラーメッセージを日本語にしたものの、
テストコードで期待するエラーメッセージがまだ英語になっているためです。
したがって、この英語のエラーメッセージを日本語のエラーメッセージに書き換える必要があります。

※Tweetモデルの失敗原因

1) テキストのみであればツイートは保存される
→Tweetモデルのバリデーションにimageも追記したので、
textとimageの両方の入力がないとツイートが保存できないようになっています。
したがって、このように失敗します。


単体テストコードを日本語に書き換えよう
UserモデルとTweetモデルの単体テストコードに記述してある、
英語のエラーメッセージを日本語に変更します。


Userモデルの単体テストを書き換えましょう
expect(@user.errors.full_messages).to include('英語のエラーメッセージ')の部分を
('日本語のエラーメッセージ')に変更します。
spec/models/user_spec.rb
require 'rails_helper'
describe User do
  before do
    @user = FactoryBot.build(:user)
  end

  describe 'ユーザー新規登録' do
    context '新規登録がうまくいくとき' do
      it 'nicknameとemail、passwordとpassword_confirmationが存在すれば登録できる' do
        expect(@user).to be_valid
      end
      it 'nicknameが6文字以下では登録できる' do
        @user.nickname = 'aaaaaa'
        expect(@user).to be_valid
      end
      it 'passwordが6文字以上であれば登録できる' do
        @user.password = '000000'
        @user.password_confirmation = '000000'
        expect(@user).to be_valid
      end
    end

    context '新規登録がうまくいかないとき' do
      it 'nicknameが空だと登録できない' do
        @user.nickname = ''
        @user.valid?
        expect(@user.errors.full_messages).to include('ニックネームを入力してください')
      end
      it 'nicknameが7文字以上であれば登録できない' do
        @user.nickname = 'aaaaaaa'
        @user.valid?
        expect(@user.errors.full_messages).to include('ニックネームは6文字以内で入力してください')
      end
      it 'emailが空では登録できない' do
        @user.email = ''
        @user.valid?
        expect(@user.errors.full_messages).to include('Eメールを入力してください')
      end
      it '重複したemailが存在する場合登録できない' do
        @user.save
        another_user = FactoryBot.build(:user)
        another_user.email = @user.email
        another_user.valid?
        expect(another_user.errors.full_messages).to include('Eメールはすでに存在します')
      end
      it 'passwordが空では登録できない' do
        @user.password = ''
        @user.valid?
        expect(@user.errors.full_messages).to include('パスワードを入力してください')
      end
      it 'passwordが5文字以下であれば登録できない' do
        @user.password = '00000'
        @user.password_confirmation = '00000'
        @user.valid?
        expect(@user.errors.full_messages).to include('パスワードは6文字以上で入力してください')
      end
      it 'passwordが存在してもpassword_confirmationが空では登録できない' do
        @user.password_confirmation = ''
        @user.valid?
        expect(@user.errors.full_messages).to include('パスワード（確認用）とパスワードの入力が一致しません')
      end
    end
  end
end


テストコードを実行しましょう
ターミナル
bundle exec rspec spec/models/user_spec.rb 

以下のログのようにテストがすべてパスしていれば成功です。
ターミナル
User
  ユーザー新規登録
    新規登録がうまくいくとき
      nicknameとemail、passwordとpassword_confirmationが存在すれば登録できる
      nicknameが6文字以下では登録できる
      passwordが6文字以上であれば登録できる
    新規登録がうまくいかないとき
      nicknameが空だと登録できない
      nicknameが7文字以上であれば登録できない
      emailが空では登録できない
      重複したemailが存在する場合登録できない
      passwordが空では登録できない
      passwordが5文字以下であれば登録できない
      passwordが存在してもpassword_confirmationが空では登録できない

Finished in 10.4 seconds (files took 7.39 seconds to load)
10 examples, 0 failures



Tweetモデルの単体テストを書き換えましょう
Userモデルの変更と同じく
expect(@user.errors.full_messages).to include('英語のエラーメッセージ')の部分を('日本語のエラーメッセージ')に変更します。

Tweetモデルには、バリデーションにimageを追記したので、textとimage両方の入力が
ないとツイートが保存できないようになっています。
したがって、'テキストのみであればツイートは保存される'の部分は、
コメントアウトか削除をしましょう。そして、imageについてのテストを追加しています。

spec/models/tweet_spec.rb
require 'rails_helper'

RSpec.describe Tweet, type: :model do
  before do
    @tweet = FactoryBot.build(:tweet)
  end

  describe 'ツイートの保存' do
    context 'ツイートが保存できる場合' do
      it '画像とテキストがあればツイートは保存される' do
        expect(@tweet).to be_valid
      end

      # ↓↓下記はコメントアウトか削除↓↓
      # it 'テキストのみであればツイートは保存される' do
      #   @tweet.image = ''
      #   expect(@tweet).to be_valid
      # end
    end

    context 'ツイートが保存できない場合' do
      it 'テキストがないとツイートは保存できない' do
        @tweet.text = ''
        @tweet.valid?
        expect(@tweet.errors.full_messages).to include('テキストを入力してください')
      end
      it '画像がないとツイートは保存できない' do
        @tweet.image = nil
        @tweet.valid?
        expect(@tweet.errors.full_messages).to include('画像を入力してください')
      end
      it 'ユーザーが紐付いていないとツイートは保存できない' do
        @tweet.user = nil
        @tweet.valid?
        expect(@tweet.errors.full_messages).to include('Userを入力してください')
      end
    end
  end
end

35行目のexpect(@tweet.errors.full_messages).to include('Userを入力してください')
のUserは、今回ja.ymlに記述してないので、Userのままで問題ありません。


テストコードを実行しましょう
ターミナル
bundle exec rspec spec/models/tweet_spec.rb

以下のログのようにテストがすべてパスしていれば成功です。
ターミナル
Tweet
  ツイートの保存
    ツイートが保存できる場合
      画像とテキストがあればツイートは保存される
    ツイートが保存できない場合
      テキストがないとツイートは保存できない
      画像がないとツイートは保存できない
      ユーザーが紐付いていないとツイートは保存できない

Finished in 0.64743 seconds (files took 4.05 seconds to load)
4 examples, 0 failures

ここまで記述し、テストコードが正常に通ったら完了です。


要点チェック
設定を変更すると、エラーメッセージを英語から日本語に変換できること
rails-i18nは、日本語に対応できるgemであること
localeファイルとは、様々な言語に対応できる言語ファイルであること
YAMLとは、中身が文字だけで記述されているプログラムであること
devise.ja.ymlとは、deviseを用いて導入したユーザー管理機能のエラーメッセージを日本語化するファイルであること
ja.ymlとは、アプリケーション上の英語を日本語へ変換するファイルであること